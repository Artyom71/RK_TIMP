# RK_TIMP
## std::vector
Cтрокa 23: вызван конструктор для создания std::vector
Количество и тип элементов равны cnt и T соответственно; элементы равны нулю.

Строка 33: с помощью метода size() получено количество элемнтов вектора rhs.

Строка 48: с помощью циклов обращаемся к i-ому или j-ому элементу std::vector и совершаем арифметические преобразования.

# std::set
Строка 20: создаём множество типа set.

Строка 22: с помщью функции cons(объявлена в строках 9-14) заполняем множество случайными числами.

Строка 25: вывод set на экран.

Сторка 31: ищем элемент множества соответствующий значению del.

Строка 39: добавляем новый элемент в set.

Строки 52-54: находим пересечение множеств s1, s2 и записываем результат в vector v_intersection.

Строки 56-58: находим объединение множеств s1, s2 и записываем результат в vector v_union.

Строки 60-61: находим разность множеств s1, s2 и записываем результат в vector v_difference.

Строка 63: очищаем множество mySet.

# std::queue
В проекте реализовывется бинарное дерево. Для печати дерева по слоям используется очередь - std::queue

Строка 207: выполняется вставка элемента в очередь.

Строка 211:  получение элемента из очереди.

Строка 212: удаление элемента из очереди.

Строки 226-227: удаление элемента из очереди.

# tree
Строка 94: получение значения узла с перегруженного оператора *.

Сторка 269: производим обнуление дерева.

Строка 49: получение крайнего правого элемента происходит с помощью функции TreeMin.

Строка 55: получение крайнего левого элемента происходит с помощью функции TreeMax.

Строка 115: получение ссылки на корень происходит с помощью поля root.
